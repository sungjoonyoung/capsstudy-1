/*

#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

for (i = 1, i <= 100, i++);
for (i = 0, i < 100, i++); // 이게 옳아
for (i = M, i > 0, i--);

배열과 포인터

배열.가장 기초저깅ㄴ 자료구조
같은 자료형을 가지는 자료 유형
;
int a, b, c, d, e,
이러면 힘들어짐
if (a != && b != c...);
이렇게

대과롷로 묶어주기
int arr[]

int arr[5] // 6칸 짜리 배열을 만든 것
인덱스 값은 0부터 시작이 된다
발류 값은 arr[인덱스 주소] 예컨데 arr[3] 이렇게


이 상황에서
printf("%d", arr[5]);
이러면 segmentation fault로 된다.
그래ㅓㅅ 프로그램을 강제 종료시키심.
마지막 인덱스는 무조건 크기의 마이너스 원

이제부터 0부터 셀 것!!


!초기화하는 방법!
int arr[5]; //몯 ㅜ쓰레기 값 들어감
int arr[5] = { 1,2,3,4,5 }; //줄괄호에 있는 것들이 하나한하 들어가 줌
int arr[] = { 1,2,3,4,5 }; //이래도 사이즈 크기 알아서 설정해 줌
int arr[5] = {1,2}//1,2,0,0,0 이렇게 들어감 쓰ㅔ릭 값 없음
char str[] = "Hello"; //문자열의 경우에는 Hello '\o' 이런 널 포인터가 들어감
//그래서 char 안에서는 6이 들어감 널 포인터도 들어가서


!포인터!
메모리의 주소값을 저장하기 위한 변수
포인터 연산자에는 두 개*, &

별은 1, 처음 선언할 떄에는 포인터라느 걸 알려주기 위한 포인터 자료형
2, 연산 과정에서 쓰일 떄는 값을 참조한다.

& 는 변수의 주소를 retrurn 하게 된다.

<예제>
int a = 10; //메모리의 한 구석에 a라는 상자 안에 10이라는 값이 들어 감. 근데 메모리 안에서 주소가 있음
// 0x0010 이라는 주소 안에 a라는 게 들어가는데 val이 10임.
int *pa = &a; //포인터는 메모리의 주소값을 설정하는 거
// pa라는 메모리가 들어가고 pa의 value 는 0x0010로 들어감.

printf("%d", a); // 10
printf("%d", *pa); // pa라는 녀석을 별연산 하겠다
// 10을 출력하게 됨 // val 안이 0x0010 이라는 주소로 가는 놈이 a를 통한 10


(*pa)++ // a = 11 이 된다.
* pa++ // a = 10 그대로 // 참조되기 전에 더해짐// 주소값이 변하고 a는 안 바뀜. // 주소값에 더해지고 그게 ㅇㅋ?

!메모리를 잘못사용하는 경우!
int *ptn;
*ptr = 200; // 이러면 기존의 값을 찾을 수가 없어서 힘들어짐. 처음부터 초기화를 잘하자!

int* ptr = 100;
*ptr = 200; // 

*은 누군가의 주소를 탐닉
& 는 나의 주소를 뱉는!

<마지막으로 배열과 포인터의 관계>

<array& printer>
int arr[3];
 // 메모리안에 세 칸이 생기겠지 // 처음의 주소를 알면 그 다음의 원소를 주소 없이 얻을 수 있겠지 // int 는 4바이트당 총총 뛰어가면서
사실상& arr[0]

참고로 int* p, int* p, 뭐든 상관 없음

int* ptr
ptr = &arr[0] !
어쩃든
ptr = arr !
이랑 똑같다.

이 상태에서.
arr[i] == *(ptr + i) !



int swap(int arr[]) // 스왑에 배열을 넣어주고 싶을 떄.
int swap(int* arr) // 똑같음

!!!!배열의 이름은 해당 배열의 첫번 쨰 주소를 가르키는 것과 같다. !!!!



char str[];
scanf("%s", &str); // 근데 여기서 &를 지워도 됨. 어짜피 배열이 포인터니까.
존나 중요!



*/

/*
!랜덤
#include <stdlib.h>
< time.h >
srand((unsigned)time(NULL))
rand() % 45 + 1;

버블정렬? bubble_sort
*/